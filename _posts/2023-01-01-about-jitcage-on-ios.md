---
layout: post
title: about JITCage on iOS
tags: [JIT, iOS, WebKit]
categories: Safari
---

* TOC
{:toc}

JITCage added to WebKit repository on [Nov 3, 2020](https://github.com/WebKit/WebKit/commit/678e6175efda5fd3c5fa15f0f582f6f517e41819).  

iPhone 13+ with A15 SoC and later affected.  

This article is about JITCage and its implementation.

# JIT and JITCage 

## JIT Code and JIT region
The JIT (Just-in-time) compiler takes intermediate code, such as bytecode, and compiling it into native machine code at runtime.  

JIT compile is used for the purpose of improving performance in programs using dynamic languages such as JavaScript. The code is executed with an interpreter, and frequently executed code is converted into optimized machine code at runtime to improve performance.  

The JIT compiler can analyze the code being executed, including the data and algorithms used, and generate optimized machine code for the specific environment in which it is running. No optimization process details in this post.  

JavaScriptCore, the JavaScript engine used by WebKit, also uses JIT compile, and the JIT code is stored in JIT region, which is a separate memory space used to store compiled code. JIT region needs write & execute permissions for dynamic code generation and execution.

## History of JIT Mitigations

JIT regions with RWX permissions are often used for browser exploits. Therefore, JIT mitigations were focused on protecting the system from malicious code executing in the JIT region. This includes techniques such as memory randomization, code signature, and access control restrictions.  

**[WebKit / Source / JavaScriptCore / jit / ExecutableAllocator.cpp](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/jit/ExecutableAllocator.cpp#L293)**
```cpp
static ALWAYS_INLINE void initializeSeparatedWXHeaps(void* stubBase, size_t stubSize, void* jitBase, size_t jitSize)
{
    auto exitScope = makeScopeExit([] {
        RELEASE_ASSERT(!g_jscConfig.useFastJITPermissions);
    });

    mach_vm_address_t writableAddr = 0;

    // 1. Create a second mapping of the JIT region at a random address.
    vm_prot_t cur, max;
    int remapFlags = VM_FLAGS_ANYWHERE;
#if defined(VM_FLAGS_RANDOM_ADDR)
    remapFlags |= VM_FLAGS_RANDOM_ADDR;
#endif
    kern_return_t ret = mach_vm_remap(mach_task_self(), &writableAddr, jitSize, 0,
        remapFlags,
        mach_task_self(), (mach_vm_address_t)jitBase, FALSE,
        &cur, &max, VM_INHERIT_DEFAULT);

    bool remapSucceeded = (ret == KERN_SUCCESS);
    if (!remapSucceeded)
        return;

    // 2. Assemble a thunk that will serve as the means for writing into the JIT region.
    MacroAssemblerCodeRef<JITThunkPtrTag> writeThunk = jitWriteThunkGenerator(reinterpret_cast<void*>(writableAddr), stubBase, stubSize);

    int result = 0;

#if USE(EXECUTE_ONLY_JIT_WRITE_FUNCTION)
    // 3. Prevent reading the write thunk code.
    result = vm_protect(mach_task_self(), reinterpret_cast<vm_address_t>(stubBase), stubSize, true, VM_PROT_EXECUTE);
    RELEASE_ASSERT(!result);
#endif

    // 4. Prevent writing into the executable JIT mapping.
    result = vm_protect(mach_task_self(), reinterpret_cast<vm_address_t>(jitBase), jitSize, true, VM_PROT_READ | VM_PROT_EXECUTE);
    RELEASE_ASSERT(!result);

    // 5. Prevent execution in the writable JIT mapping.
    result = vm_protect(mach_task_self(), static_cast<vm_address_t>(writableAddr), jitSize, true, VM_PROT_READ | VM_PROT_WRITE);
    RELEASE_ASSERT(!result);

    // 6. Zero out writableAddr to avoid leaking the address of the writable mapping.
    memset_s(&writableAddr, sizeof(writableAddr), 0, sizeof(writableAddr));

#if ENABLE(SEPARATED_WX_HEAP)
    g_jscConfig.jitWriteSeparateHeaps = reinterpret_cast<JITWriteSeparateHeapsFunction>(writeThunk.code().taggedPtr());
#endif
}
```

### 1) before iOS 10

- JIT region is mapped with RWX permissions, in which you can write and execute arbitrary code here.

### 2) iOS 10+, iPhone 5s+

- Mitigation : seperated_wx_heap
  - Create two virtual mappings to the same physical JIT memory with one executable and one writable.  
  - The address of writable memory is protected by XOM(eXecute-Only Memory). Emit specialized jit write function with writable address encoded as immediate values. This function is generated by the jitWriteThunk Generator and protected with excute only permission. The address of writable memory is not revealed within the process.
- Bypass
  - The memory address is not revealed, but you can copy the code at the offset location by calling the `jitWriteSeparateHeaps` function. This function is a pointer to the jit write function inlined in the execute-only area.

**[WebKit / Source / JavaScriptCore / jit / ExecutableAllocator.h](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/jit/ExecutableAllocator.h#L136)**
```cpp
#if ENABLE(SEPARATED_WX_HEAP)
        if (g_jscConfig.jitWriteSeparateHeaps) {
            // Use execute-only write thunk for writes inside the JIT region. This is a variant of
            // memcpy that takes an offset into the JIT region as its destination (first) parameter.
            off_t offset = (off_t)((uintptr_t)dst - startOfFixedExecutableMemoryPool<uintptr_t>());
            retagCodePtr<JITThunkPtrTag, CFunctionPtrTag>(g_jscConfig.jitWriteSeparateHeaps)(offset, src, n);
            RELEASE_ASSERT(!Gigacage::contains(src));
            return dst;
        }
#endif
```

### 3) iOS 10+ on iPhone 8+ (A11+)

- Mitigation : APRR
  - A11 SoC supports `FAST_JIT_PERMISSIONS`. The mapping for the JIT region has been changed to only have one mapping. It takes R-X permission and changes it to RW- permission only when code generation is necessary to copy the code. (Switching using system register)
  - A11 SoC supports `FAST_JIT_PERMISSIONS`. The mapping for the JIT region has been changed back to only have one mapping. It uses R-X permission and changes it to RW- permission only when copies the code (permission switching using system register). After the code copy is complete, set the R-X permission again.
- Bypass 1
  - The `performJITMemcpy` function grants write permission to the JIT region and write the code. Find and jump to `linkcode` gadget for inlined `performJITMemcpy`. This function takes a JIT region address as an argument. You can find it by reading g_config(.startExecutableMemory/.endExecutableMemory).

**[WebKit / Source / JavaScriptCore / jit / ExecutableAllocator.h](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/jit/ExecutableAllocator.h#L129)**
```cpp
// static ALWAYS_INLINE void* performJITMemcpy(void *dst, const void *src, size_t n);
        if (g_jscConfig.useFastJITPermissions) {
            threadSelfRestrictRWXToRW();
            memcpy(dst, src, n);
            threadSelfRestrictRWXToRX();
            return dst;
        }
```
**[WebKit / Source / JavaScriptCore / jit / ExecutableAllocator.cpp](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/jit/ExecutableAllocator.cpp#L523)**
```cpp
    void* memoryStart() { return g_jscConfig.startExecutableMemory; }
    void* memoryEnd() { return g_jscConfig.endExecutableMemory; }
```
- Bypass 2
  - Overwrite the [AssemblerBuffer](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/assembler/AssemblerBuffer.h#L293), which temporarily stores the compiled JIT code, before copying it to the JIT region.

**[WebKit / Source / JavaScriptCore / assembler / LinkBuffer.cpp](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/assembler/LinkBuffer.cpp#L429)**
```cpp
AssemblerBuffer& buffer = macroAssembler.m_assembler.buffer();
...
performJITMemcpy(code, buffer.data(), buffer.codeSize());
```

### 4) iPhone XS+ (A12+)

- Mitigation : PAC, JIT code signature
  - PAC(Pointer Authentication Code) prevents code reuse attacks like ROP(Return-Oriented Programming) and JOP(Jump-Oriented Programming). Add authentication code to pointer and validate to ensure that it has not been modified by an attacker. Generate authentication code for instruction pointer with IA/IB key and data pointer with DA/DB key.
  - This made calling gadgets like `performJITMemcpy` difficult. We need gadget pointers signed with pac.


  - [JIT code signature](https://github.com/WebKit/WebKit/commit/a190853078db354853acfb767b3ffca16cf4e3ac) is PAC-based software mitigation. [Generate PAC-based instruction hash](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/assembler/AssemblerBuffer.h#L280) in hash storage during code emit in AssemblerBuffer. [Verify instruction hash](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/assembler/LinkBuffer.cpp#L234) before JIT copy operation.
  - PAC and JIT code signature continue to be strengthened.
- Bypass
  - There are various ways to bypass PAC, but the most common way to bypass PAC is to write and execute arbitrary code in JIT region.
  - To write arbitrary code in JIT region, PAC bypass is required.

### 5) iPhone 13+ (A15+)

- Mitigation : JITCage
  - JITCage is sandboxing for JIT regions. Prevent arbitrary function calls, restrict executable instructions, and use different A/B key than the process when signing and verifying PACs.
- Bypass
  - ðŸ˜›

## Entitlements

By the iOS Security Model, device is protected by code signing. In the process of installation, runtime, update, etc., it is verified that it has valid code signing, which indicates that it is a reliable code and has not been tampered with.  

So dynamic code generation is limited, iOS uses the `dynamic-codesigning` entitlement to enable the JIT feature. Process with this entitlement can allocate a memory with MAP_JIT flag. Dynamic code signing is allowed for this memory.

To use the JITCage feature, `com.apple.private.verified-jit` entitlement is also required.  

**[WebKit / Source / JavaScriptCore / entitlements.plist](https://github.com/WebKit/WebKit/blob/ad2e13b2a8e69c2ea538cdb8c7cb101a40555266/Source/JavaScriptCore/entitlements.plist)**  
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>com.apple.private.verified-jit</key>
	<true/>
	<key>com.apple.security.cs.single-jit</key>
	<true/>
	<key>dynamic-codesigning</key>
	<true/>
</dict>
</plist>
```
- com.apple.private.verified-jit
  - enable JITCage feature
- com.apple.security.cs.single-jit
  - limits a process to a single JIT region (macOS entitlement)
- dynamic-codesigning
  - enable JIT

# Let's see what happens

The following is description of JITCage in the [commit](https://github.com/WebKit/WebKit/commit/678e6175efda5fd3c5fa15f0f582f6f517e41819).

> Towards software verified JIT, this patch adds partial JIT-Caging support which cages JIT call / jumps in a certain format.  
This is currently only enabled when internal SDK is enabled. And it is only enabled in ARM64E for now.  
Currently, this patch does not have CSS JIT support. Subsequent patch will add it.
We ensured that JS2 and RAMification are neutral.  

JITCage limits JIT instructions, restricts call/jump to prevent jumps to unexpected locations.  

Not much information has been released. The following materials contain about JITCage. But analysis required for more information.
1. [https://www.synacktiv.com/sites/default/files/2022-10/attacking_safari_in_2022_slides.pdf](https://www.synacktiv.com/sites/default/files/2022-10/attacking_safari_in_2022_slides.pdf)
2. [https://www.youtube.com/watch?v=8mQAYeozl5I](https://www.youtube.com/watch?v=8mQAYeozl5I)

## New Flags and New Header

These are requirements for enabling JITCage and JIT Operation Validation.  

[WebKit / Source / WTF / wtf / PlatformEnable.h # L862](https://github.com/WebKit/WebKit/blob/16a66f7561b54ca47761eabaea1b6ddbfa5e03ae/Source/WTF/wtf/PlatformEnable.h#L862)
```cpp
#if OS(DARWIN) && ENABLE(JIT) && USE(APPLE_INTERNAL_SDK) && CPU(ARM64E) && HAVE(JIT_CAGE) && !PLATFORM(MAC)
#define ENABLE_JIT_CAGE 1
#endif

#if OS(DARWIN) && CPU(ADDRESS64) && ENABLE(JIT) && (ENABLE(JIT_CAGE) || ASSERT_ENABLED)
#define ENABLE_JIT_OPERATION_VALIDATION 1
#endif
```

`JIT_CAGE` is for JIT sandboxing. `JIT_OPERATION_VALIDATION` is for validate JIT-caged pointers.  

```cpp
#if ENABLE(JIT_CAGE)
#include <WebKitAdditions/JITCageAdditions.h>
#else // ENABLE(JIT_CAGE)
```
JITCageAdditions.h of the WebKitAdditions framework in APPLE_INTERNAL_SDK provides an interface for JITCage. Naturally, `ENABLE(APPLE_INTERNAL_SDK)` must be true to use JITCage.  

### New mmap Flags
[WebKit / Source / WTF / wtf / posix / OSAllocatorPOSIX.cpp](https://github.com/WebKit/WebKit/blob/16a66f7561b54ca47761eabaea1b6ddbfa5e03ae/Source/WTF/wtf/posix/OSAllocatorPOSIX.cpp)
```cpp
        #if OS(DARWIN)
            if (executable) {
                if (jitCageEnabled)
                    flags |= MAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE;
                else
                    flags |= MAP_EXECUTABLE_FOR_JIT;
            }
        #else
...
    result = mmap(result, bytes, protection, flags, fd, 0);
```
When allocating JITCage memory, the mmap function is called with a new flag `MAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE`. This flag is defined in JITCageAdditions.h.  

- OSAllocator::reserveUncommitted in IDA  

![mmap](/assets/img/230201_00_mmap.png)  

`MAP_EXECUTABLE_FOR_JIT` is 0x1802,  
`MAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE` is 0x11802.   

```cpp
/*
 * Flags contain sharing type and options.
 * Sharing types; choose one.
 */
#define MAP_SHARED      0x0001          /* [MF|SHM] share changes */
#define MAP_PRIVATE     0x0002          /* [MF|SHM] changes are private */
#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define MAP_COPY        MAP_PRIVATE     /* Obsolete */
#endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */

/*
 * Other flags
 */
#define MAP_FIXED        0x0010 /* [MF|SHM] interpret addr exactly */
#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)
#define MAP_RENAME       0x0020 /* Sun: rename private pages to file */
#define MAP_NORESERVE    0x0040 /* Sun: don't reserve needed swap area */
#define MAP_RESERVED0080 0x0080 /* previously unimplemented MAP_INHERIT */
#define MAP_NOEXTEND     0x0100 /* for MAP_FILE, don't change file size */
#define MAP_HASSEMAPHORE 0x0200 /* region may contain semaphores */
#define MAP_NOCACHE      0x0400 /* don't cache pages for this mapping */
#define MAP_JIT          0x0800 /* Allocate a region that will be used for JIT purposes */

/*
 * Mapping type
 */
#define MAP_FILE        0x0000  /* map from file (default) */
#define MAP_ANON        0x1000  /* allocated from memory, swap space */
#define MAP_ANONYMOUS   MAP_ANON
```
`MAP_EXECUTABLE_FOR_JIT` means `(MAP_ANON(0x1000) | MAP_JIT(0x0800) | MAP_PRIVATE(0x0002))`. `MAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE` means `(MAP_EXECUTABLE_FOR_JIT | MAP_JITCAGE(0x10000))`  

(`MAP_JITCAGE` is not an official name. The exact flag name is unknown because the flag does not appear in the published XNU open source.)  

- mmap in IDA  

![mmap](/assets/img/230201_01_map_jitcage.png)

The mmap function called with the `MAP_JITCAGE` flag checks the "com.apple.private.verified-jit" entitlement and allocates the JITCaged page.  

## Generate instructions for JIT code

The assembler generated in the JITCage area is slightly different. (See LIntThunks.cpp, MacroAssemblerARM64E.h)  

> Trace this flow :<br>
createJSGateThunk(pointer, tag, name) â†’ jit.call(reg, tag) â†’ callRegister(reg, lr)

LLIntThunks.cpp : createJSGateThunk(...)
```cpp
jit.call(GPRInfo::regT5, tag);
```
MacroAssemblerARM64E.h : call(...)
```cpp
ALWAYS_INLINE Call call(RegisterID targetGPR, PtrTag tag)
{
    ASSERT(tag != CFunctionPtrTag && tag != NoPtrTag);
    ASSERT(!Options::useJITCage() || callerType(tag) == PtrTagCallerType::JIT);
    move(TrustedImm64(tag), ARM64Registers::lr);
    if (calleeType(tag) == PtrTagCalleeType::JIT)
        return callRegister<CallSignatureType::JITCall>(targetGPR, ARM64Registers::lr);
    return callRegister<CallSignatureType::NativeCall>(targetGPR, ARM64Registers::lr);
}
```
MacroAssemblerARM64E.h : callRegister(...)
```cpp
template<CallSignatureType type>
ALWAYS_INLINE Call callRegister(RegisterID targetGPR, RegisterID tagGPR = InvalidGPR)
{
    UNUSED_PARAM(type);
    ASSERT(tagGPR != targetGPR);
    invalidateAllTempRegisters();
#if ENABLE(JIT_CAGE)
    if (Options::useJITCage()) {
        JSC_JIT_CAGED_CALL(type, targetGPR, tagGPR);
    } else
#endif
        m_assembler.blrab(targetGPR, tagGPR);
    return Call(m_assembler.labelIgnoringWatchpoints(), Call::None);
}
```
Different instructions are generated depending on whether the target being called into the register is JIT code or native code.  
Since there is no published code for `JSC_JIT_CAGED_CALL` in callRegister function, let's see IDA.  

![ins-00](/assets/img/230201_02_ins.png)  

These are the functions inlined in `JSC::LLInt::createJSGateThunk`.  

`BLRAB X5, X30` was generated for register calls, but it has been changed to generate `BLRAA X5, X30` for register calls pointing to native code in the JITCaged environment.  

![ins-01](/assets/img/230201_03_ins.png)  

![ins-02](/assets/img/230201_04_ins.png)  

In case of calling native code from JITCage, not only register call, but also calling `trustedPtr` or `farJump`, it has been changed to use IA key instead of IB key to verify PAC.  

## PACIA not working

When calling native code from JITCage, BRAA/BLRAA is used, so calling native code requires a PACed pointer using JITCage IA key.  

However, within a JITCage page, PACIA do not generate PAC tagging. Because of this, it is not easy to jump to the native code even if the shellcode is executed on the JIT page.  

As a result of the execution, tag is not inserted into the pointer even if the PACIA is executed.

PACIA for JIT code ptr : 
```js
0x10000200; // ADR    X0, #0x40
0xDAC10020; // PACIA  X0, X1
0x44444444;
```
![pacia-00](/assets/img/230201_08_pacia.png)  

## PACIB only for JIT Code ptr

Within the JITCage page, PACIB operates only on pointers within the JIT page.  

If the target pointer signed by PACIB is within the scope of the JIT page, a PAC tagged value is generated, but not for other pointers.  

PACIB for JIT code ptr : 
```js
0x10000200; // ADR    X0, #0x40
0xdac10420; // PACIB  X0, X1
0x44444444;
```
![pacib-01](/assets/img/230201_10_pacib.png)  

PACIB for Native code ptr : 
```js
0x10000200; // ADR    X0, #0x40
0xF9400000; // LDR    X0, [X0]  ; address of native code
0xDAC10420; // PACIB  X0, X1
0x44444444;
```
![pacib-00](/assets/img/230201_09_pacib.png)  

## Undefined Instructions

So, why not use a BR instruction that does not verify the PAC? , but the BR instruction is not available.  

test for BR instruction :  
```js
0xD2882820; // MOV  X0, #0x4141
0xD61F0000; // BR   X0
```

![crash-01](/assets/img/230201_05_crash.png)  
![crash-03](/assets/img/230201_07_crash.png)  

BR, RET, SVC, etc. instructions are undefined and cannot be used.  

# Conclusion

Since BR, RET, SVC, etc. cannot be used in shellcode written in JITCage, PAC bypass is required to jump to native code. 

However, in JITCage, PACIA does not work and PACIB works only for JIT code ptr. So direct PAC signature generation for arbitrary address is restricted. It is difficult to call arbitrary address.  

In order to call native code from JITCage, pointer signature using JITCage IA key must be achieved.  

# Ref.
1. https://github.com/WebKit/WebKit/commit/678e6175efda5fd3c5fa15f0f582f6f517e41819
2. https://trac.webkit.org/wiki/AppleWebKitGoalsfor2021
3. https://opensource.apple.com/source/xnu/xnu-7195.141.2/bsd/kern/kern_mman.c.auto.html
4. https://www.blackhat.com/docs/us-16/materials/us-16-Krstic.pdf