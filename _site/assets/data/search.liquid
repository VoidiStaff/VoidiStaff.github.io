[
  
  {
    "title"    : "about JITCage on iOS",
    "category" : "",
    "tags"     : " JIT, iOS, WebKit",
    "url"      : "/safari/2023/01/01/about-jitcage-on-ios.html",
    "date"     : "January 1, 2023",
    "excerpt"  : "\n  JIT and JITCage    \n      JIT Code and JIT region\n      History of JIT Mitigations        \n          1) before iOS 10\n          2) iOS 10+, iPhone 5s+\n          3) iOS 10+ on iPhone 8+ (A11+)\n          4) iPhone XS+ (A12+)\n          5) iPhone 1...",
  "content"  : "\n  JIT and JITCage    \n      JIT Code and JIT region\n      History of JIT Mitigations        \n          1) before iOS 10\n          2) iOS 10+, iPhone 5s+\n          3) iOS 10+ on iPhone 8+ (A11+)\n          4) iPhone XS+ (A12+)\n          5) iPhone 13+ (A15+)\n        \n      \n      Entitlements\n    \n  \n  Let’s see what happens    \n      New Flags and New Header        \n          New mmap Flags\n        \n      \n      Generate instructions for JIT code\n      PACIA not working\n      PACIB only for JIT Code ptr\n      Undefined Instructions\n    \n  \n  Conclusion\n  Ref.\n\n\nJITCage added to WebKit repository on Nov 3, 2020.\n\niPhone 13+ with A15 SoC and later affected.\n\nThis article is about JITCage and its implementation.\n\nJIT and JITCage\n\nJIT Code and JIT region\nThe JIT (Just-in-time) compiler takes intermediate code, such as bytecode, and compiling it into native machine code at runtime.\n\nJIT compile is used for the purpose of improving performance in programs using dynamic languages such as JavaScript. The code is executed with an interpreter, and frequently executed code is converted into optimized machine code at runtime to improve performance.\n\nThe JIT compiler can analyze the code being executed, including the data and algorithms used, and generate optimized machine code for the specific environment in which it is running. No optimization process details in this post.\n\nJavaScriptCore, the JavaScript engine used by WebKit, also uses JIT compile, and the JIT code is stored in JIT region, which is a separate memory space used to store compiled code. JIT region needs write &amp;amp; execute permissions for dynamic code generation and execution.\n\nHistory of JIT Mitigations\n\nJIT regions with RWX permissions are often used for browser exploits. Therefore, JIT mitigations were focused on protecting the system from malicious code executing in the JIT region. This includes techniques such as memory randomization, code signature, and access control restrictions.\n\nWebKit / Source / JavaScriptCore / jit / ExecutableAllocator.cpp\nstatic ALWAYS_INLINE void initializeSeparatedWXHeaps(void* stubBase, size_t stubSize, void* jitBase, size_t jitSize)\n{\n    auto exitScope = makeScopeExit([] {\n        RELEASE_ASSERT(!g_jscConfig.useFastJITPermissions);\n    });\n\n    mach_vm_address_t writableAddr = 0;\n\n    // 1. Create a second mapping of the JIT region at a random address.\n    vm_prot_t cur, max;\n    int remapFlags = VM_FLAGS_ANYWHERE;\n#if defined(VM_FLAGS_RANDOM_ADDR)\n    remapFlags |= VM_FLAGS_RANDOM_ADDR;\n#endif\n    kern_return_t ret = mach_vm_remap(mach_task_self(), &amp;amp;writableAddr, jitSize, 0,\n        remapFlags,\n        mach_task_self(), (mach_vm_address_t)jitBase, FALSE,\n        &amp;amp;cur, &amp;amp;max, VM_INHERIT_DEFAULT);\n\n    bool remapSucceeded = (ret == KERN_SUCCESS);\n    if (!remapSucceeded)\n        return;\n\n    // 2. Assemble a thunk that will serve as the means for writing into the JIT region.\n    MacroAssemblerCodeRef&amp;lt;JITThunkPtrTag&amp;gt; writeThunk = jitWriteThunkGenerator(reinterpret_cast&amp;lt;void*&amp;gt;(writableAddr), stubBase, stubSize);\n\n    int result = 0;\n\n#if USE(EXECUTE_ONLY_JIT_WRITE_FUNCTION)\n    // 3. Prevent reading the write thunk code.\n    result = vm_protect(mach_task_self(), reinterpret_cast&amp;lt;vm_address_t&amp;gt;(stubBase), stubSize, true, VM_PROT_EXECUTE);\n    RELEASE_ASSERT(!result);\n#endif\n\n    // 4. Prevent writing into the executable JIT mapping.\n    result = vm_protect(mach_task_self(), reinterpret_cast&amp;lt;vm_address_t&amp;gt;(jitBase), jitSize, true, VM_PROT_READ | VM_PROT_EXECUTE);\n    RELEASE_ASSERT(!result);\n\n    // 5. Prevent execution in the writable JIT mapping.\n    result = vm_protect(mach_task_self(), static_cast&amp;lt;vm_address_t&amp;gt;(writableAddr), jitSize, true, VM_PROT_READ | VM_PROT_WRITE);\n    RELEASE_ASSERT(!result);\n\n    // 6. Zero out writableAddr to avoid leaking the address of the writable mapping.\n    memset_s(&amp;amp;writableAddr, sizeof(writableAddr), 0, sizeof(writableAddr));\n\n#if ENABLE(SEPARATED_WX_HEAP)\n    g_jscConfig.jitWriteSeparateHeaps = reinterpret_cast&amp;lt;JITWriteSeparateHeapsFunction&amp;gt;(writeThunk.code().taggedPtr());\n#endif\n}\n\n\n1) before iOS 10\n\n\n  JIT region is mapped with RWX permissions, in which you can write and execute arbitrary code here.\n\n\n2) iOS 10+, iPhone 5s+\n\n\n  Mitigation : seperated_wx_heap\n    \n      Create two virtual mappings to the same physical JIT memory with one executable and one writable.\n      The address of writable memory is protected by XOM(eXecute-Only Memory). Emit specialized jit write function with writable address encoded as immediate values. This function is generated by the jitWriteThunk Generator and protected with excute only permission. The address of writable memory is not revealed within the process.\n    \n  \n  Bypass\n    \n      The memory address is not revealed, but you can copy the code at the offset location by calling the jitWriteSeparateHeaps function. This function is a pointer to the jit write function inlined in the execute-only area.\n    \n  \n\n\nWebKit / Source / JavaScriptCore / jit / ExecutableAllocator.h\n#if ENABLE(SEPARATED_WX_HEAP)\n        if (g_jscConfig.jitWriteSeparateHeaps) {\n            // Use execute-only write thunk for writes inside the JIT region. This is a variant of\n            // memcpy that takes an offset into the JIT region as its destination (first) parameter.\n            off_t offset = (off_t)((uintptr_t)dst - startOfFixedExecutableMemoryPool&amp;lt;uintptr_t&amp;gt;());\n            retagCodePtr&amp;lt;JITThunkPtrTag, CFunctionPtrTag&amp;gt;(g_jscConfig.jitWriteSeparateHeaps)(offset, src, n);\n            RELEASE_ASSERT(!Gigacage::contains(src));\n            return dst;\n        }\n#endif\n\n\n3) iOS 10+ on iPhone 8+ (A11+)\n\n\n  Mitigation : APRR\n    \n      A11 SoC supports FAST_JIT_PERMISSIONS. The mapping for the JIT region has been changed to only have one mapping. It takes R-X permission and changes it to RW- permission only when code generation is necessary to copy the code. (Switching using system register)\n      A11 SoC supports FAST_JIT_PERMISSIONS. The mapping for the JIT region has been changed back to only have one mapping. It uses R-X permission and changes it to RW- permission only when copies the code (permission switching using system register). After the code copy is complete, set the R-X permission again.\n    \n  \n  Bypass 1\n    \n      The performJITMemcpy function grants write permission to the JIT region and write the code. Find and jump to linkcode gadget for inlined performJITMemcpy. This function takes a JIT region address as an argument. You can find it by reading g_config(.startExecutableMemory/.endExecutableMemory).\n    \n  \n\n\nWebKit / Source / JavaScriptCore / jit / ExecutableAllocator.h\n// static ALWAYS_INLINE void* performJITMemcpy(void *dst, const void *src, size_t n);\n        if (g_jscConfig.useFastJITPermissions) {\n            threadSelfRestrictRWXToRW();\n            memcpy(dst, src, n);\n            threadSelfRestrictRWXToRX();\n            return dst;\n        }\n\nWebKit / Source / JavaScriptCore / jit / ExecutableAllocator.cpp\n    void* memoryStart() { return g_jscConfig.startExecutableMemory; }\n    void* memoryEnd() { return g_jscConfig.endExecutableMemory; }\n\n\n  Bypass 2\n    \n      Overwrite the AssemblerBuffer, which temporarily stores the compiled JIT code, before copying it to the JIT region.\n    \n  \n\n\nWebKit / Source / JavaScriptCore / assembler / LinkBuffer.cpp\nAssemblerBuffer&amp;amp; buffer = macroAssembler.m_assembler.buffer();\n...\nperformJITMemcpy(code, buffer.data(), buffer.codeSize());\n\n\n4) iPhone XS+ (A12+)\n\n\n  Mitigation : PAC, JIT code signature\n    \n      PAC(Pointer Authentication Code) prevents code reuse attacks like ROP(Return-Oriented Programming) and JOP(Jump-Oriented Programming). Add authentication code to pointer and validate to ensure that it has not been modified by an attacker. Generate authentication code for instruction pointer with IA/IB key and data pointer with DA/DB key.\n      \n        This made calling gadgets like performJITMemcpy difficult. We need gadget pointers signed with pac.\n      \n      JIT code signature is PAC-based software mitigation. Generate PAC-based instruction hash in hash storage during code emit in AssemblerBuffer. Verify instruction hash before JIT copy operation.\n      PAC and JIT code signature continue to be strengthened.\n    \n  \n  Bypass\n    \n      There are various ways to bypass PAC, but the most common way to bypass PAC is to write and execute arbitrary code in JIT region.\n      To write arbitrary code in JIT region, PAC bypass is required.\n    \n  \n\n\n5) iPhone 13+ (A15+)\n\n\n  Mitigation : JITCage\n    \n      JITCage is sandboxing for JIT regions. Prevent arbitrary function calls, restrict executable instructions, and use different A/B key than the process when signing and verifying PACs.\n    \n  \n  Bypass\n    \n      (ˉ﹃ˉ)\n    \n  \n\n\nEntitlements\n\nBy the iOS Security Model, device is protected by code signing. In the process of installation, runtime, update, etc., it is verified that it has valid code signing, which indicates that it is a reliable code and has not been tampered with.\n\nSo dynamic code generation is limited, iOS uses the dynamic-codesigning entitlement to enable the JIT feature. Process with this entitlement can allocate a memory with MAP_JIT flag. Dynamic code signing is allowed for this memory.\n\nTo use the JITCage feature, com.apple.private.verified-jit entitlement is also required.\n\nWebKit / Source / JavaScriptCore / entitlements.plist\n&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;\n&amp;lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&amp;gt;\n&amp;lt;plist version=&quot;1.0&quot;&amp;gt;\n&amp;lt;dict&amp;gt;\n\t&amp;lt;key&amp;gt;com.apple.private.verified-jit&amp;lt;/key&amp;gt;\n\t&amp;lt;true/&amp;gt;\n\t&amp;lt;key&amp;gt;com.apple.security.cs.single-jit&amp;lt;/key&amp;gt;\n\t&amp;lt;true/&amp;gt;\n\t&amp;lt;key&amp;gt;dynamic-codesigning&amp;lt;/key&amp;gt;\n\t&amp;lt;true/&amp;gt;\n&amp;lt;/dict&amp;gt;\n&amp;lt;/plist&amp;gt;\n\n\n  com.apple.private.verified-jit\n    \n      enable JITCage feature\n    \n  \n  com.apple.security.cs.single-jit\n    \n      limits a process to a single JIT region (macOS entitlement)\n    \n  \n  dynamic-codesigning\n    \n      enable JIT\n    \n  \n\n\nLet’s see what happens\n\nThe following is description of JITCage in the commit.\n\n\n  Towards software verified JIT, this patch adds partial JIT-Caging support which cages JIT call / jumps in a certain format.\nThis is currently only enabled when internal SDK is enabled. And it is only enabled in ARM64E for now.\nCurrently, this patch does not have CSS JIT support. Subsequent patch will add it.\nWe ensured that JS2 and RAMification are neutral.\n\n\nJITCage limits JIT instructions, restricts call/jump to prevent jumps to unexpected locations.\n\nNot much information has been released. The following materials contain about JITCage. But analysis required for more information.\n\n  https://www.synacktiv.com/sites/default/files/2022-10/attacking_safari_in_2022_slides.pdf\n  https://www.youtube.com/watch?v=8mQAYeozl5I\n\n\nNew Flags and New Header\n\nThese are requirements for enabling JITCage and JIT Operation Validation.\n\nWebKit / Source / WTF / wtf / PlatformEnable.h # L862\n#if OS(DARWIN) &amp;amp;&amp;amp; ENABLE(JIT) &amp;amp;&amp;amp; USE(APPLE_INTERNAL_SDK) &amp;amp;&amp;amp; CPU(ARM64E) &amp;amp;&amp;amp; HAVE(JIT_CAGE) &amp;amp;&amp;amp; !PLATFORM(MAC)\n#define ENABLE_JIT_CAGE 1\n#endif\n\n#if OS(DARWIN) &amp;amp;&amp;amp; CPU(ADDRESS64) &amp;amp;&amp;amp; ENABLE(JIT) &amp;amp;&amp;amp; (ENABLE(JIT_CAGE) || ASSERT_ENABLED)\n#define ENABLE_JIT_OPERATION_VALIDATION 1\n#endif\n\n\nJIT_CAGE is for JIT sandboxing. JIT_OPERATION_VALIDATION is for validate JIT-caged pointers.\n\n#if ENABLE(JIT_CAGE)\n#include &amp;lt;WebKitAdditions/JITCageAdditions.h&amp;gt;\n#else // ENABLE(JIT_CAGE)\n\nJITCageAdditions.h of the WebKitAdditions framework in APPLE_INTERNAL_SDK provides an interface for JITCage. Naturally, ENABLE(APPLE_INTERNAL_SDK) must be true to use JITCage.\n\nNew mmap Flags\nWebKit / Source / WTF / wtf / posix / OSAllocatorPOSIX.cpp\n        #if OS(DARWIN)\n            if (executable) {\n                if (jitCageEnabled)\n                    flags |= MAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE;\n                else\n                    flags |= MAP_EXECUTABLE_FOR_JIT;\n            }\n        #else\n...\n    result = mmap(result, bytes, protection, flags, fd, 0);\n\nWhen allocating JITCage memory, the mmap function is called with a new flag MAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE. This flag is defined in JITCageAdditions.h.\n\n\n  OSAllocator::reserveUncommitted in IDA\n\n\n\n\nMAP_EXECUTABLE_FOR_JIT is 0x1802,\nMAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE is 0x11802.\n\n/*\n * Flags contain sharing type and options.\n * Sharing types; choose one.\n */\n#define MAP_SHARED      0x0001          /* [MF|SHM] share changes */\n#define MAP_PRIVATE     0x0002          /* [MF|SHM] changes are private */\n#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)\n#define MAP_COPY        MAP_PRIVATE     /* Obsolete */\n#endif  /* (!_POSIX_C_SOURCE || _DARWIN_C_SOURCE) */\n\n/*\n * Other flags\n */\n#define MAP_FIXED        0x0010 /* [MF|SHM] interpret addr exactly */\n#if !defined(_POSIX_C_SOURCE) || defined(_DARWIN_C_SOURCE)\n#define MAP_RENAME       0x0020 /* Sun: rename private pages to file */\n#define MAP_NORESERVE    0x0040 /* Sun: don&#39;t reserve needed swap area */\n#define MAP_RESERVED0080 0x0080 /* previously unimplemented MAP_INHERIT */\n#define MAP_NOEXTEND     0x0100 /* for MAP_FILE, don&#39;t change file size */\n#define MAP_HASSEMAPHORE 0x0200 /* region may contain semaphores */\n#define MAP_NOCACHE      0x0400 /* don&#39;t cache pages for this mapping */\n#define MAP_JIT          0x0800 /* Allocate a region that will be used for JIT purposes */\n\n/*\n * Mapping type\n */\n#define MAP_FILE        0x0000  /* map from file (default) */\n#define MAP_ANON        0x1000  /* allocated from memory, swap space */\n#define MAP_ANONYMOUS   MAP_ANON\n\nMAP_EXECUTABLE_FOR_JIT means (MAP_ANON(0x1000) | MAP_JIT(0x0800) | MAP_PRIVATE(0x0002)). MAP_EXECUTABLE_FOR_JIT_WITH_JIT_CAGE means (MAP_EXECUTABLE_FOR_JIT | MAP_JITCAGE(0x10000))\n\n(MAP_JITCAGE is not an official name. The exact flag name is unknown because the flag does not appear in the published XNU open source.)\n\n\n  mmap in IDA\n\n\n\n\nThe mmap function called with the MAP_JITCAGE flag checks the “com.apple.private.verified-jit” entitlement and allocates the JITCaged page.\n\nGenerate instructions for JIT code\n\nThe assembler generated in the JITCage area is slightly different. (See LIntThunks.cpp, MacroAssemblerARM64E.h)\n\nThe instructions generated by JITCage are slightly different.\n\n  Trace this flow :\ncreateJSGateThunk(pointer, tag, name) → jit.call(reg, tag) → callRegister(reg, lr)\n\n\nLLIntThunks.cpp : createJSGateThunk(…)\njit.call(GPRInfo::regT5, tag);\n\nMacroAssemblerARM64E.h : call(…)\nALWAYS_INLINE Call call(RegisterID targetGPR, PtrTag tag)\n{\n    ASSERT(tag != CFunctionPtrTag &amp;amp;&amp;amp; tag != NoPtrTag);\n    ASSERT(!Options::useJITCage() || callerType(tag) == PtrTagCallerType::JIT);\n    move(TrustedImm64(tag), ARM64Registers::lr);\n    if (calleeType(tag) == PtrTagCalleeType::JIT)\n        return callRegister&amp;lt;CallSignatureType::JITCall&amp;gt;(targetGPR, ARM64Registers::lr);\n    return callRegister&amp;lt;CallSignatureType::NativeCall&amp;gt;(targetGPR, ARM64Registers::lr);\n}\n\nMacroAssemblerARM64E.h : callRegister(…)\ntemplate&amp;lt;CallSignatureType type&amp;gt;\nALWAYS_INLINE Call callRegister(RegisterID targetGPR, RegisterID tagGPR = InvalidGPR)\n{\n    UNUSED_PARAM(type);\n    ASSERT(tagGPR != targetGPR);\n    invalidateAllTempRegisters();\n#if ENABLE(JIT_CAGE)\n    if (Options::useJITCage()) {\n        JSC_JIT_CAGED_CALL(type, targetGPR, tagGPR);\n    } else\n#endif\n        m_assembler.blrab(targetGPR, tagGPR);\n    return Call(m_assembler.labelIgnoringWatchpoints(), Call::None);\n}\n\nDifferent instructions are generated depending on whether the target being called into the register is JIT code or native code.\nSince there is no published code for JSC_JIT_CAGED_CALL in callRegister function, let’s see IDA.\n\n\n\nThese are the functions inlined in JSC::LLInt::createJSGateThunk.\n\nBLRAB X5, X30 was generated for register calls, but it has been changed to generate BLRAA X5, X30 for register calls pointing to native code in the JITCaged environment.\n\n\n\n\n\nIn case of calling native code from JITCage, not only register call, but also calling trustedPtr or farJump, it has been changed to use IA key instead of IB key to verify PAC.\n\nPACIA not working\n\nWhen calling native code from JITCage, BRAA/BLRAA is used, so calling native code requires a PACed pointer using JITCage IA key.\n\nHowever, within a JITCage page, PACIA do not generate PAC tagging. Because of this, it is not easy to jump to the native code even if the shellcode is executed on the JIT page.\n\nAs a result of the execution, tag is not inserted into the pointer even if the PACIA is executed.\n\nPACIA for JIT code ptr :\n0x10000200; // ADR    X0, #0x40\n0xDAC10020; // PACIA  X0, X1\n0x44444444;\n\n\n\nPACIB only for JIT Code ptr\n\nWithin the JITCage page, PACIB operates only on pointers within the JIT page.\n\nIf the target pointer signed by PACIB is within the scope of the JIT page, a PAC tagged value is generated, but not for other pointers.\n\nPACIB for JIT code ptr :\n0x10000200; // ADR    X0, #0x40\n0xdac10420; // PACIB  X0, X1\n0x44444444;\n\n\n\nPACIB for Native code ptr :\n0x10000200; // ADR    X0, #0x40\n0xF9400000; // LDR    X0, [X0]  ; address of native code\n0xDAC10420; // PACIB  X0, X1\n0x44444444;\n\n\n\nUndefined Instructions\n\nSo, why not use a BR instruction that does not verify the PAC? , but the BR instruction is not available.\n\ntest for BR instruction :\n0xD2882820; // MOV  X0, #0x4141\n0xD61F0000; // BR   X0\n\n\n\n\n\nBR, RET, SVC, etc. instructions are undefined and cannot be used.\n\nConclusion\n\nSince BR, RET, SVC, etc. cannot be used in shellcode written in JITCage, PAC bypass is required to jump to native code.\n\nHowever, in JITCage, PACIA does not work and PACIB works only for JIT code ptr. So direct PAC signature generation for arbitrary address is restricted. It is difficult to call arbitrary address.\n\nIn order to call native code from JITCage, pointer signature using JITCage IA key must be achieved.\n\nRef.\n\n  https://github.com/WebKit/WebKit/commit/678e6175efda5fd3c5fa15f0f582f6f517e41819\n  https://trac.webkit.org/wiki/AppleWebKitGoalsfor2021\n  https://opensource.apple.com/source/xnu/xnu-7195.141.2/bsd/kern/kern_mman.c.auto.html\n  https://www.blackhat.com/docs/us-16/materials/us-16-Krstic.pdf\n\n"
} 
  
  
  
]
